
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `ScheduleLocation` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums.js"
import type * as Prisma from "../internal/prismaNamespace.js"

/**
 * Model ScheduleLocation
 * 
 */
export type ScheduleLocationModel = runtime.Types.Result.DefaultSelection<Prisma.$ScheduleLocationPayload>

export type AggregateScheduleLocation = {
  _count: ScheduleLocationCountAggregateOutputType | null
  _avg: ScheduleLocationAvgAggregateOutputType | null
  _sum: ScheduleLocationSumAggregateOutputType | null
  _min: ScheduleLocationMinAggregateOutputType | null
  _max: ScheduleLocationMaxAggregateOutputType | null
}

export type ScheduleLocationAvgAggregateOutputType = {
  id: number | null
  unitScheduleId: number | null
  trainingLocationId: number | null
  plannedCount: number | null
  actualCount: number | null
  requiredCount: number | null
}

export type ScheduleLocationSumAggregateOutputType = {
  id: number | null
  unitScheduleId: number | null
  trainingLocationId: number | null
  plannedCount: number | null
  actualCount: number | null
  requiredCount: number | null
}

export type ScheduleLocationMinAggregateOutputType = {
  id: number | null
  unitScheduleId: number | null
  trainingLocationId: number | null
  plannedCount: number | null
  actualCount: number | null
  requiredCount: number | null
}

export type ScheduleLocationMaxAggregateOutputType = {
  id: number | null
  unitScheduleId: number | null
  trainingLocationId: number | null
  plannedCount: number | null
  actualCount: number | null
  requiredCount: number | null
}

export type ScheduleLocationCountAggregateOutputType = {
  id: number
  unitScheduleId: number
  trainingLocationId: number
  plannedCount: number
  actualCount: number
  requiredCount: number
  _all: number
}


export type ScheduleLocationAvgAggregateInputType = {
  id?: true
  unitScheduleId?: true
  trainingLocationId?: true
  plannedCount?: true
  actualCount?: true
  requiredCount?: true
}

export type ScheduleLocationSumAggregateInputType = {
  id?: true
  unitScheduleId?: true
  trainingLocationId?: true
  plannedCount?: true
  actualCount?: true
  requiredCount?: true
}

export type ScheduleLocationMinAggregateInputType = {
  id?: true
  unitScheduleId?: true
  trainingLocationId?: true
  plannedCount?: true
  actualCount?: true
  requiredCount?: true
}

export type ScheduleLocationMaxAggregateInputType = {
  id?: true
  unitScheduleId?: true
  trainingLocationId?: true
  plannedCount?: true
  actualCount?: true
  requiredCount?: true
}

export type ScheduleLocationCountAggregateInputType = {
  id?: true
  unitScheduleId?: true
  trainingLocationId?: true
  plannedCount?: true
  actualCount?: true
  requiredCount?: true
  _all?: true
}

export type ScheduleLocationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ScheduleLocation to aggregate.
   */
  where?: Prisma.ScheduleLocationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ScheduleLocations to fetch.
   */
  orderBy?: Prisma.ScheduleLocationOrderByWithRelationInput | Prisma.ScheduleLocationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.ScheduleLocationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ScheduleLocations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ScheduleLocations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned ScheduleLocations
  **/
  _count?: true | ScheduleLocationCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: ScheduleLocationAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: ScheduleLocationSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: ScheduleLocationMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: ScheduleLocationMaxAggregateInputType
}

export type GetScheduleLocationAggregateType<T extends ScheduleLocationAggregateArgs> = {
      [P in keyof T & keyof AggregateScheduleLocation]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateScheduleLocation[P]>
    : Prisma.GetScalarType<T[P], AggregateScheduleLocation[P]>
}




export type ScheduleLocationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.ScheduleLocationWhereInput
  orderBy?: Prisma.ScheduleLocationOrderByWithAggregationInput | Prisma.ScheduleLocationOrderByWithAggregationInput[]
  by: Prisma.ScheduleLocationScalarFieldEnum[] | Prisma.ScheduleLocationScalarFieldEnum
  having?: Prisma.ScheduleLocationScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: ScheduleLocationCountAggregateInputType | true
  _avg?: ScheduleLocationAvgAggregateInputType
  _sum?: ScheduleLocationSumAggregateInputType
  _min?: ScheduleLocationMinAggregateInputType
  _max?: ScheduleLocationMaxAggregateInputType
}

export type ScheduleLocationGroupByOutputType = {
  id: number
  unitScheduleId: number
  trainingLocationId: number
  plannedCount: number | null
  actualCount: number | null
  requiredCount: number | null
  _count: ScheduleLocationCountAggregateOutputType | null
  _avg: ScheduleLocationAvgAggregateOutputType | null
  _sum: ScheduleLocationSumAggregateOutputType | null
  _min: ScheduleLocationMinAggregateOutputType | null
  _max: ScheduleLocationMaxAggregateOutputType | null
}

type GetScheduleLocationGroupByPayload<T extends ScheduleLocationGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<ScheduleLocationGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof ScheduleLocationGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], ScheduleLocationGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], ScheduleLocationGroupByOutputType[P]>
      }
    >
  >



export type ScheduleLocationWhereInput = {
  AND?: Prisma.ScheduleLocationWhereInput | Prisma.ScheduleLocationWhereInput[]
  OR?: Prisma.ScheduleLocationWhereInput[]
  NOT?: Prisma.ScheduleLocationWhereInput | Prisma.ScheduleLocationWhereInput[]
  id?: Prisma.IntFilter<"ScheduleLocation"> | number
  unitScheduleId?: Prisma.IntFilter<"ScheduleLocation"> | number
  trainingLocationId?: Prisma.IntFilter<"ScheduleLocation"> | number
  plannedCount?: Prisma.IntNullableFilter<"ScheduleLocation"> | number | null
  actualCount?: Prisma.IntNullableFilter<"ScheduleLocation"> | number | null
  requiredCount?: Prisma.IntNullableFilter<"ScheduleLocation"> | number | null
  schedule?: Prisma.XOR<Prisma.UnitScheduleScalarRelationFilter, Prisma.UnitScheduleWhereInput>
  location?: Prisma.XOR<Prisma.TrainingLocationScalarRelationFilter, Prisma.TrainingLocationWhereInput>
}

export type ScheduleLocationOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  unitScheduleId?: Prisma.SortOrder
  trainingLocationId?: Prisma.SortOrder
  plannedCount?: Prisma.SortOrderInput | Prisma.SortOrder
  actualCount?: Prisma.SortOrderInput | Prisma.SortOrder
  requiredCount?: Prisma.SortOrderInput | Prisma.SortOrder
  schedule?: Prisma.UnitScheduleOrderByWithRelationInput
  location?: Prisma.TrainingLocationOrderByWithRelationInput
}

export type ScheduleLocationWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  unitScheduleId_trainingLocationId?: Prisma.ScheduleLocationUnitScheduleIdTrainingLocationIdCompoundUniqueInput
  AND?: Prisma.ScheduleLocationWhereInput | Prisma.ScheduleLocationWhereInput[]
  OR?: Prisma.ScheduleLocationWhereInput[]
  NOT?: Prisma.ScheduleLocationWhereInput | Prisma.ScheduleLocationWhereInput[]
  unitScheduleId?: Prisma.IntFilter<"ScheduleLocation"> | number
  trainingLocationId?: Prisma.IntFilter<"ScheduleLocation"> | number
  plannedCount?: Prisma.IntNullableFilter<"ScheduleLocation"> | number | null
  actualCount?: Prisma.IntNullableFilter<"ScheduleLocation"> | number | null
  requiredCount?: Prisma.IntNullableFilter<"ScheduleLocation"> | number | null
  schedule?: Prisma.XOR<Prisma.UnitScheduleScalarRelationFilter, Prisma.UnitScheduleWhereInput>
  location?: Prisma.XOR<Prisma.TrainingLocationScalarRelationFilter, Prisma.TrainingLocationWhereInput>
}, "id" | "unitScheduleId_trainingLocationId">

export type ScheduleLocationOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  unitScheduleId?: Prisma.SortOrder
  trainingLocationId?: Prisma.SortOrder
  plannedCount?: Prisma.SortOrderInput | Prisma.SortOrder
  actualCount?: Prisma.SortOrderInput | Prisma.SortOrder
  requiredCount?: Prisma.SortOrderInput | Prisma.SortOrder
  _count?: Prisma.ScheduleLocationCountOrderByAggregateInput
  _avg?: Prisma.ScheduleLocationAvgOrderByAggregateInput
  _max?: Prisma.ScheduleLocationMaxOrderByAggregateInput
  _min?: Prisma.ScheduleLocationMinOrderByAggregateInput
  _sum?: Prisma.ScheduleLocationSumOrderByAggregateInput
}

export type ScheduleLocationScalarWhereWithAggregatesInput = {
  AND?: Prisma.ScheduleLocationScalarWhereWithAggregatesInput | Prisma.ScheduleLocationScalarWhereWithAggregatesInput[]
  OR?: Prisma.ScheduleLocationScalarWhereWithAggregatesInput[]
  NOT?: Prisma.ScheduleLocationScalarWhereWithAggregatesInput | Prisma.ScheduleLocationScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"ScheduleLocation"> | number
  unitScheduleId?: Prisma.IntWithAggregatesFilter<"ScheduleLocation"> | number
  trainingLocationId?: Prisma.IntWithAggregatesFilter<"ScheduleLocation"> | number
  plannedCount?: Prisma.IntNullableWithAggregatesFilter<"ScheduleLocation"> | number | null
  actualCount?: Prisma.IntNullableWithAggregatesFilter<"ScheduleLocation"> | number | null
  requiredCount?: Prisma.IntNullableWithAggregatesFilter<"ScheduleLocation"> | number | null
}

export type ScheduleLocationCreateInput = {
  plannedCount?: number | null
  actualCount?: number | null
  requiredCount?: number | null
  schedule: Prisma.UnitScheduleCreateNestedOneWithoutScheduleLocationsInput
  location: Prisma.TrainingLocationCreateNestedOneWithoutScheduleLocationsInput
}

export type ScheduleLocationUncheckedCreateInput = {
  id?: number
  unitScheduleId: number
  trainingLocationId: number
  plannedCount?: number | null
  actualCount?: number | null
  requiredCount?: number | null
}

export type ScheduleLocationUpdateInput = {
  plannedCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  actualCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  requiredCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  schedule?: Prisma.UnitScheduleUpdateOneRequiredWithoutScheduleLocationsNestedInput
  location?: Prisma.TrainingLocationUpdateOneRequiredWithoutScheduleLocationsNestedInput
}

export type ScheduleLocationUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  unitScheduleId?: Prisma.IntFieldUpdateOperationsInput | number
  trainingLocationId?: Prisma.IntFieldUpdateOperationsInput | number
  plannedCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  actualCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  requiredCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}

export type ScheduleLocationCreateManyInput = {
  id?: number
  unitScheduleId: number
  trainingLocationId: number
  plannedCount?: number | null
  actualCount?: number | null
  requiredCount?: number | null
}

export type ScheduleLocationUpdateManyMutationInput = {
  plannedCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  actualCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  requiredCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}

export type ScheduleLocationUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  unitScheduleId?: Prisma.IntFieldUpdateOperationsInput | number
  trainingLocationId?: Prisma.IntFieldUpdateOperationsInput | number
  plannedCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  actualCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  requiredCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}

export type ScheduleLocationListRelationFilter = {
  every?: Prisma.ScheduleLocationWhereInput
  some?: Prisma.ScheduleLocationWhereInput
  none?: Prisma.ScheduleLocationWhereInput
}

export type ScheduleLocationOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type ScheduleLocationUnitScheduleIdTrainingLocationIdCompoundUniqueInput = {
  unitScheduleId: number
  trainingLocationId: number
}

export type ScheduleLocationCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  unitScheduleId?: Prisma.SortOrder
  trainingLocationId?: Prisma.SortOrder
  plannedCount?: Prisma.SortOrder
  actualCount?: Prisma.SortOrder
  requiredCount?: Prisma.SortOrder
}

export type ScheduleLocationAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  unitScheduleId?: Prisma.SortOrder
  trainingLocationId?: Prisma.SortOrder
  plannedCount?: Prisma.SortOrder
  actualCount?: Prisma.SortOrder
  requiredCount?: Prisma.SortOrder
}

export type ScheduleLocationMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  unitScheduleId?: Prisma.SortOrder
  trainingLocationId?: Prisma.SortOrder
  plannedCount?: Prisma.SortOrder
  actualCount?: Prisma.SortOrder
  requiredCount?: Prisma.SortOrder
}

export type ScheduleLocationMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  unitScheduleId?: Prisma.SortOrder
  trainingLocationId?: Prisma.SortOrder
  plannedCount?: Prisma.SortOrder
  actualCount?: Prisma.SortOrder
  requiredCount?: Prisma.SortOrder
}

export type ScheduleLocationSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  unitScheduleId?: Prisma.SortOrder
  trainingLocationId?: Prisma.SortOrder
  plannedCount?: Prisma.SortOrder
  actualCount?: Prisma.SortOrder
  requiredCount?: Prisma.SortOrder
}

export type ScheduleLocationCreateNestedManyWithoutLocationInput = {
  create?: Prisma.XOR<Prisma.ScheduleLocationCreateWithoutLocationInput, Prisma.ScheduleLocationUncheckedCreateWithoutLocationInput> | Prisma.ScheduleLocationCreateWithoutLocationInput[] | Prisma.ScheduleLocationUncheckedCreateWithoutLocationInput[]
  connectOrCreate?: Prisma.ScheduleLocationCreateOrConnectWithoutLocationInput | Prisma.ScheduleLocationCreateOrConnectWithoutLocationInput[]
  createMany?: Prisma.ScheduleLocationCreateManyLocationInputEnvelope
  connect?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
}

export type ScheduleLocationUncheckedCreateNestedManyWithoutLocationInput = {
  create?: Prisma.XOR<Prisma.ScheduleLocationCreateWithoutLocationInput, Prisma.ScheduleLocationUncheckedCreateWithoutLocationInput> | Prisma.ScheduleLocationCreateWithoutLocationInput[] | Prisma.ScheduleLocationUncheckedCreateWithoutLocationInput[]
  connectOrCreate?: Prisma.ScheduleLocationCreateOrConnectWithoutLocationInput | Prisma.ScheduleLocationCreateOrConnectWithoutLocationInput[]
  createMany?: Prisma.ScheduleLocationCreateManyLocationInputEnvelope
  connect?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
}

export type ScheduleLocationUpdateManyWithoutLocationNestedInput = {
  create?: Prisma.XOR<Prisma.ScheduleLocationCreateWithoutLocationInput, Prisma.ScheduleLocationUncheckedCreateWithoutLocationInput> | Prisma.ScheduleLocationCreateWithoutLocationInput[] | Prisma.ScheduleLocationUncheckedCreateWithoutLocationInput[]
  connectOrCreate?: Prisma.ScheduleLocationCreateOrConnectWithoutLocationInput | Prisma.ScheduleLocationCreateOrConnectWithoutLocationInput[]
  upsert?: Prisma.ScheduleLocationUpsertWithWhereUniqueWithoutLocationInput | Prisma.ScheduleLocationUpsertWithWhereUniqueWithoutLocationInput[]
  createMany?: Prisma.ScheduleLocationCreateManyLocationInputEnvelope
  set?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  disconnect?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  delete?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  connect?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  update?: Prisma.ScheduleLocationUpdateWithWhereUniqueWithoutLocationInput | Prisma.ScheduleLocationUpdateWithWhereUniqueWithoutLocationInput[]
  updateMany?: Prisma.ScheduleLocationUpdateManyWithWhereWithoutLocationInput | Prisma.ScheduleLocationUpdateManyWithWhereWithoutLocationInput[]
  deleteMany?: Prisma.ScheduleLocationScalarWhereInput | Prisma.ScheduleLocationScalarWhereInput[]
}

export type ScheduleLocationUncheckedUpdateManyWithoutLocationNestedInput = {
  create?: Prisma.XOR<Prisma.ScheduleLocationCreateWithoutLocationInput, Prisma.ScheduleLocationUncheckedCreateWithoutLocationInput> | Prisma.ScheduleLocationCreateWithoutLocationInput[] | Prisma.ScheduleLocationUncheckedCreateWithoutLocationInput[]
  connectOrCreate?: Prisma.ScheduleLocationCreateOrConnectWithoutLocationInput | Prisma.ScheduleLocationCreateOrConnectWithoutLocationInput[]
  upsert?: Prisma.ScheduleLocationUpsertWithWhereUniqueWithoutLocationInput | Prisma.ScheduleLocationUpsertWithWhereUniqueWithoutLocationInput[]
  createMany?: Prisma.ScheduleLocationCreateManyLocationInputEnvelope
  set?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  disconnect?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  delete?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  connect?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  update?: Prisma.ScheduleLocationUpdateWithWhereUniqueWithoutLocationInput | Prisma.ScheduleLocationUpdateWithWhereUniqueWithoutLocationInput[]
  updateMany?: Prisma.ScheduleLocationUpdateManyWithWhereWithoutLocationInput | Prisma.ScheduleLocationUpdateManyWithWhereWithoutLocationInput[]
  deleteMany?: Prisma.ScheduleLocationScalarWhereInput | Prisma.ScheduleLocationScalarWhereInput[]
}

export type ScheduleLocationCreateNestedManyWithoutScheduleInput = {
  create?: Prisma.XOR<Prisma.ScheduleLocationCreateWithoutScheduleInput, Prisma.ScheduleLocationUncheckedCreateWithoutScheduleInput> | Prisma.ScheduleLocationCreateWithoutScheduleInput[] | Prisma.ScheduleLocationUncheckedCreateWithoutScheduleInput[]
  connectOrCreate?: Prisma.ScheduleLocationCreateOrConnectWithoutScheduleInput | Prisma.ScheduleLocationCreateOrConnectWithoutScheduleInput[]
  createMany?: Prisma.ScheduleLocationCreateManyScheduleInputEnvelope
  connect?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
}

export type ScheduleLocationUncheckedCreateNestedManyWithoutScheduleInput = {
  create?: Prisma.XOR<Prisma.ScheduleLocationCreateWithoutScheduleInput, Prisma.ScheduleLocationUncheckedCreateWithoutScheduleInput> | Prisma.ScheduleLocationCreateWithoutScheduleInput[] | Prisma.ScheduleLocationUncheckedCreateWithoutScheduleInput[]
  connectOrCreate?: Prisma.ScheduleLocationCreateOrConnectWithoutScheduleInput | Prisma.ScheduleLocationCreateOrConnectWithoutScheduleInput[]
  createMany?: Prisma.ScheduleLocationCreateManyScheduleInputEnvelope
  connect?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
}

export type ScheduleLocationUpdateManyWithoutScheduleNestedInput = {
  create?: Prisma.XOR<Prisma.ScheduleLocationCreateWithoutScheduleInput, Prisma.ScheduleLocationUncheckedCreateWithoutScheduleInput> | Prisma.ScheduleLocationCreateWithoutScheduleInput[] | Prisma.ScheduleLocationUncheckedCreateWithoutScheduleInput[]
  connectOrCreate?: Prisma.ScheduleLocationCreateOrConnectWithoutScheduleInput | Prisma.ScheduleLocationCreateOrConnectWithoutScheduleInput[]
  upsert?: Prisma.ScheduleLocationUpsertWithWhereUniqueWithoutScheduleInput | Prisma.ScheduleLocationUpsertWithWhereUniqueWithoutScheduleInput[]
  createMany?: Prisma.ScheduleLocationCreateManyScheduleInputEnvelope
  set?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  disconnect?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  delete?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  connect?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  update?: Prisma.ScheduleLocationUpdateWithWhereUniqueWithoutScheduleInput | Prisma.ScheduleLocationUpdateWithWhereUniqueWithoutScheduleInput[]
  updateMany?: Prisma.ScheduleLocationUpdateManyWithWhereWithoutScheduleInput | Prisma.ScheduleLocationUpdateManyWithWhereWithoutScheduleInput[]
  deleteMany?: Prisma.ScheduleLocationScalarWhereInput | Prisma.ScheduleLocationScalarWhereInput[]
}

export type ScheduleLocationUncheckedUpdateManyWithoutScheduleNestedInput = {
  create?: Prisma.XOR<Prisma.ScheduleLocationCreateWithoutScheduleInput, Prisma.ScheduleLocationUncheckedCreateWithoutScheduleInput> | Prisma.ScheduleLocationCreateWithoutScheduleInput[] | Prisma.ScheduleLocationUncheckedCreateWithoutScheduleInput[]
  connectOrCreate?: Prisma.ScheduleLocationCreateOrConnectWithoutScheduleInput | Prisma.ScheduleLocationCreateOrConnectWithoutScheduleInput[]
  upsert?: Prisma.ScheduleLocationUpsertWithWhereUniqueWithoutScheduleInput | Prisma.ScheduleLocationUpsertWithWhereUniqueWithoutScheduleInput[]
  createMany?: Prisma.ScheduleLocationCreateManyScheduleInputEnvelope
  set?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  disconnect?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  delete?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  connect?: Prisma.ScheduleLocationWhereUniqueInput | Prisma.ScheduleLocationWhereUniqueInput[]
  update?: Prisma.ScheduleLocationUpdateWithWhereUniqueWithoutScheduleInput | Prisma.ScheduleLocationUpdateWithWhereUniqueWithoutScheduleInput[]
  updateMany?: Prisma.ScheduleLocationUpdateManyWithWhereWithoutScheduleInput | Prisma.ScheduleLocationUpdateManyWithWhereWithoutScheduleInput[]
  deleteMany?: Prisma.ScheduleLocationScalarWhereInput | Prisma.ScheduleLocationScalarWhereInput[]
}

export type ScheduleLocationCreateWithoutLocationInput = {
  plannedCount?: number | null
  actualCount?: number | null
  requiredCount?: number | null
  schedule: Prisma.UnitScheduleCreateNestedOneWithoutScheduleLocationsInput
}

export type ScheduleLocationUncheckedCreateWithoutLocationInput = {
  id?: number
  unitScheduleId: number
  plannedCount?: number | null
  actualCount?: number | null
  requiredCount?: number | null
}

export type ScheduleLocationCreateOrConnectWithoutLocationInput = {
  where: Prisma.ScheduleLocationWhereUniqueInput
  create: Prisma.XOR<Prisma.ScheduleLocationCreateWithoutLocationInput, Prisma.ScheduleLocationUncheckedCreateWithoutLocationInput>
}

export type ScheduleLocationCreateManyLocationInputEnvelope = {
  data: Prisma.ScheduleLocationCreateManyLocationInput | Prisma.ScheduleLocationCreateManyLocationInput[]
  skipDuplicates?: boolean
}

export type ScheduleLocationUpsertWithWhereUniqueWithoutLocationInput = {
  where: Prisma.ScheduleLocationWhereUniqueInput
  update: Prisma.XOR<Prisma.ScheduleLocationUpdateWithoutLocationInput, Prisma.ScheduleLocationUncheckedUpdateWithoutLocationInput>
  create: Prisma.XOR<Prisma.ScheduleLocationCreateWithoutLocationInput, Prisma.ScheduleLocationUncheckedCreateWithoutLocationInput>
}

export type ScheduleLocationUpdateWithWhereUniqueWithoutLocationInput = {
  where: Prisma.ScheduleLocationWhereUniqueInput
  data: Prisma.XOR<Prisma.ScheduleLocationUpdateWithoutLocationInput, Prisma.ScheduleLocationUncheckedUpdateWithoutLocationInput>
}

export type ScheduleLocationUpdateManyWithWhereWithoutLocationInput = {
  where: Prisma.ScheduleLocationScalarWhereInput
  data: Prisma.XOR<Prisma.ScheduleLocationUpdateManyMutationInput, Prisma.ScheduleLocationUncheckedUpdateManyWithoutLocationInput>
}

export type ScheduleLocationScalarWhereInput = {
  AND?: Prisma.ScheduleLocationScalarWhereInput | Prisma.ScheduleLocationScalarWhereInput[]
  OR?: Prisma.ScheduleLocationScalarWhereInput[]
  NOT?: Prisma.ScheduleLocationScalarWhereInput | Prisma.ScheduleLocationScalarWhereInput[]
  id?: Prisma.IntFilter<"ScheduleLocation"> | number
  unitScheduleId?: Prisma.IntFilter<"ScheduleLocation"> | number
  trainingLocationId?: Prisma.IntFilter<"ScheduleLocation"> | number
  plannedCount?: Prisma.IntNullableFilter<"ScheduleLocation"> | number | null
  actualCount?: Prisma.IntNullableFilter<"ScheduleLocation"> | number | null
  requiredCount?: Prisma.IntNullableFilter<"ScheduleLocation"> | number | null
}

export type ScheduleLocationCreateWithoutScheduleInput = {
  plannedCount?: number | null
  actualCount?: number | null
  requiredCount?: number | null
  location: Prisma.TrainingLocationCreateNestedOneWithoutScheduleLocationsInput
}

export type ScheduleLocationUncheckedCreateWithoutScheduleInput = {
  id?: number
  trainingLocationId: number
  plannedCount?: number | null
  actualCount?: number | null
  requiredCount?: number | null
}

export type ScheduleLocationCreateOrConnectWithoutScheduleInput = {
  where: Prisma.ScheduleLocationWhereUniqueInput
  create: Prisma.XOR<Prisma.ScheduleLocationCreateWithoutScheduleInput, Prisma.ScheduleLocationUncheckedCreateWithoutScheduleInput>
}

export type ScheduleLocationCreateManyScheduleInputEnvelope = {
  data: Prisma.ScheduleLocationCreateManyScheduleInput | Prisma.ScheduleLocationCreateManyScheduleInput[]
  skipDuplicates?: boolean
}

export type ScheduleLocationUpsertWithWhereUniqueWithoutScheduleInput = {
  where: Prisma.ScheduleLocationWhereUniqueInput
  update: Prisma.XOR<Prisma.ScheduleLocationUpdateWithoutScheduleInput, Prisma.ScheduleLocationUncheckedUpdateWithoutScheduleInput>
  create: Prisma.XOR<Prisma.ScheduleLocationCreateWithoutScheduleInput, Prisma.ScheduleLocationUncheckedCreateWithoutScheduleInput>
}

export type ScheduleLocationUpdateWithWhereUniqueWithoutScheduleInput = {
  where: Prisma.ScheduleLocationWhereUniqueInput
  data: Prisma.XOR<Prisma.ScheduleLocationUpdateWithoutScheduleInput, Prisma.ScheduleLocationUncheckedUpdateWithoutScheduleInput>
}

export type ScheduleLocationUpdateManyWithWhereWithoutScheduleInput = {
  where: Prisma.ScheduleLocationScalarWhereInput
  data: Prisma.XOR<Prisma.ScheduleLocationUpdateManyMutationInput, Prisma.ScheduleLocationUncheckedUpdateManyWithoutScheduleInput>
}

export type ScheduleLocationCreateManyLocationInput = {
  id?: number
  unitScheduleId: number
  plannedCount?: number | null
  actualCount?: number | null
  requiredCount?: number | null
}

export type ScheduleLocationUpdateWithoutLocationInput = {
  plannedCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  actualCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  requiredCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  schedule?: Prisma.UnitScheduleUpdateOneRequiredWithoutScheduleLocationsNestedInput
}

export type ScheduleLocationUncheckedUpdateWithoutLocationInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  unitScheduleId?: Prisma.IntFieldUpdateOperationsInput | number
  plannedCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  actualCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  requiredCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}

export type ScheduleLocationUncheckedUpdateManyWithoutLocationInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  unitScheduleId?: Prisma.IntFieldUpdateOperationsInput | number
  plannedCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  actualCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  requiredCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}

export type ScheduleLocationCreateManyScheduleInput = {
  id?: number
  trainingLocationId: number
  plannedCount?: number | null
  actualCount?: number | null
  requiredCount?: number | null
}

export type ScheduleLocationUpdateWithoutScheduleInput = {
  plannedCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  actualCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  requiredCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  location?: Prisma.TrainingLocationUpdateOneRequiredWithoutScheduleLocationsNestedInput
}

export type ScheduleLocationUncheckedUpdateWithoutScheduleInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  trainingLocationId?: Prisma.IntFieldUpdateOperationsInput | number
  plannedCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  actualCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  requiredCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}

export type ScheduleLocationUncheckedUpdateManyWithoutScheduleInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  trainingLocationId?: Prisma.IntFieldUpdateOperationsInput | number
  plannedCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  actualCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  requiredCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}



export type ScheduleLocationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  unitScheduleId?: boolean
  trainingLocationId?: boolean
  plannedCount?: boolean
  actualCount?: boolean
  requiredCount?: boolean
  schedule?: boolean | Prisma.UnitScheduleDefaultArgs<ExtArgs>
  location?: boolean | Prisma.TrainingLocationDefaultArgs<ExtArgs>
}, ExtArgs["result"]["scheduleLocation"]>

export type ScheduleLocationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  unitScheduleId?: boolean
  trainingLocationId?: boolean
  plannedCount?: boolean
  actualCount?: boolean
  requiredCount?: boolean
  schedule?: boolean | Prisma.UnitScheduleDefaultArgs<ExtArgs>
  location?: boolean | Prisma.TrainingLocationDefaultArgs<ExtArgs>
}, ExtArgs["result"]["scheduleLocation"]>

export type ScheduleLocationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  unitScheduleId?: boolean
  trainingLocationId?: boolean
  plannedCount?: boolean
  actualCount?: boolean
  requiredCount?: boolean
  schedule?: boolean | Prisma.UnitScheduleDefaultArgs<ExtArgs>
  location?: boolean | Prisma.TrainingLocationDefaultArgs<ExtArgs>
}, ExtArgs["result"]["scheduleLocation"]>

export type ScheduleLocationSelectScalar = {
  id?: boolean
  unitScheduleId?: boolean
  trainingLocationId?: boolean
  plannedCount?: boolean
  actualCount?: boolean
  requiredCount?: boolean
}

export type ScheduleLocationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "unitScheduleId" | "trainingLocationId" | "plannedCount" | "actualCount" | "requiredCount", ExtArgs["result"]["scheduleLocation"]>
export type ScheduleLocationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  schedule?: boolean | Prisma.UnitScheduleDefaultArgs<ExtArgs>
  location?: boolean | Prisma.TrainingLocationDefaultArgs<ExtArgs>
}
export type ScheduleLocationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  schedule?: boolean | Prisma.UnitScheduleDefaultArgs<ExtArgs>
  location?: boolean | Prisma.TrainingLocationDefaultArgs<ExtArgs>
}
export type ScheduleLocationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  schedule?: boolean | Prisma.UnitScheduleDefaultArgs<ExtArgs>
  location?: boolean | Prisma.TrainingLocationDefaultArgs<ExtArgs>
}

export type $ScheduleLocationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "ScheduleLocation"
  objects: {
    schedule: Prisma.$UnitSchedulePayload<ExtArgs>
    location: Prisma.$TrainingLocationPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    unitScheduleId: number
    trainingLocationId: number
    plannedCount: number | null
    actualCount: number | null
    requiredCount: number | null
  }, ExtArgs["result"]["scheduleLocation"]>
  composites: {}
}

export type ScheduleLocationGetPayload<S extends boolean | null | undefined | ScheduleLocationDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$ScheduleLocationPayload, S>

export type ScheduleLocationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<ScheduleLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ScheduleLocationCountAggregateInputType | true
  }

export interface ScheduleLocationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduleLocation'], meta: { name: 'ScheduleLocation' } }
  /**
   * Find zero or one ScheduleLocation that matches the filter.
   * @param {ScheduleLocationFindUniqueArgs} args - Arguments to find a ScheduleLocation
   * @example
   * // Get one ScheduleLocation
   * const scheduleLocation = await prisma.scheduleLocation.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends ScheduleLocationFindUniqueArgs>(args: Prisma.SelectSubset<T, ScheduleLocationFindUniqueArgs<ExtArgs>>): Prisma.Prisma__ScheduleLocationClient<runtime.Types.Result.GetResult<Prisma.$ScheduleLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one ScheduleLocation that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {ScheduleLocationFindUniqueOrThrowArgs} args - Arguments to find a ScheduleLocation
   * @example
   * // Get one ScheduleLocation
   * const scheduleLocation = await prisma.scheduleLocation.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends ScheduleLocationFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, ScheduleLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__ScheduleLocationClient<runtime.Types.Result.GetResult<Prisma.$ScheduleLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ScheduleLocation that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ScheduleLocationFindFirstArgs} args - Arguments to find a ScheduleLocation
   * @example
   * // Get one ScheduleLocation
   * const scheduleLocation = await prisma.scheduleLocation.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends ScheduleLocationFindFirstArgs>(args?: Prisma.SelectSubset<T, ScheduleLocationFindFirstArgs<ExtArgs>>): Prisma.Prisma__ScheduleLocationClient<runtime.Types.Result.GetResult<Prisma.$ScheduleLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first ScheduleLocation that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ScheduleLocationFindFirstOrThrowArgs} args - Arguments to find a ScheduleLocation
   * @example
   * // Get one ScheduleLocation
   * const scheduleLocation = await prisma.scheduleLocation.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends ScheduleLocationFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, ScheduleLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__ScheduleLocationClient<runtime.Types.Result.GetResult<Prisma.$ScheduleLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more ScheduleLocations that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ScheduleLocationFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ScheduleLocations
   * const scheduleLocations = await prisma.scheduleLocation.findMany()
   * 
   * // Get first 10 ScheduleLocations
   * const scheduleLocations = await prisma.scheduleLocation.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const scheduleLocationWithIdOnly = await prisma.scheduleLocation.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends ScheduleLocationFindManyArgs>(args?: Prisma.SelectSubset<T, ScheduleLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ScheduleLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a ScheduleLocation.
   * @param {ScheduleLocationCreateArgs} args - Arguments to create a ScheduleLocation.
   * @example
   * // Create one ScheduleLocation
   * const ScheduleLocation = await prisma.scheduleLocation.create({
   *   data: {
   *     // ... data to create a ScheduleLocation
   *   }
   * })
   * 
   */
  create<T extends ScheduleLocationCreateArgs>(args: Prisma.SelectSubset<T, ScheduleLocationCreateArgs<ExtArgs>>): Prisma.Prisma__ScheduleLocationClient<runtime.Types.Result.GetResult<Prisma.$ScheduleLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many ScheduleLocations.
   * @param {ScheduleLocationCreateManyArgs} args - Arguments to create many ScheduleLocations.
   * @example
   * // Create many ScheduleLocations
   * const scheduleLocation = await prisma.scheduleLocation.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends ScheduleLocationCreateManyArgs>(args?: Prisma.SelectSubset<T, ScheduleLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many ScheduleLocations and returns the data saved in the database.
   * @param {ScheduleLocationCreateManyAndReturnArgs} args - Arguments to create many ScheduleLocations.
   * @example
   * // Create many ScheduleLocations
   * const scheduleLocation = await prisma.scheduleLocation.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many ScheduleLocations and only return the `id`
   * const scheduleLocationWithIdOnly = await prisma.scheduleLocation.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends ScheduleLocationCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, ScheduleLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ScheduleLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a ScheduleLocation.
   * @param {ScheduleLocationDeleteArgs} args - Arguments to delete one ScheduleLocation.
   * @example
   * // Delete one ScheduleLocation
   * const ScheduleLocation = await prisma.scheduleLocation.delete({
   *   where: {
   *     // ... filter to delete one ScheduleLocation
   *   }
   * })
   * 
   */
  delete<T extends ScheduleLocationDeleteArgs>(args: Prisma.SelectSubset<T, ScheduleLocationDeleteArgs<ExtArgs>>): Prisma.Prisma__ScheduleLocationClient<runtime.Types.Result.GetResult<Prisma.$ScheduleLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one ScheduleLocation.
   * @param {ScheduleLocationUpdateArgs} args - Arguments to update one ScheduleLocation.
   * @example
   * // Update one ScheduleLocation
   * const scheduleLocation = await prisma.scheduleLocation.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends ScheduleLocationUpdateArgs>(args: Prisma.SelectSubset<T, ScheduleLocationUpdateArgs<ExtArgs>>): Prisma.Prisma__ScheduleLocationClient<runtime.Types.Result.GetResult<Prisma.$ScheduleLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more ScheduleLocations.
   * @param {ScheduleLocationDeleteManyArgs} args - Arguments to filter ScheduleLocations to delete.
   * @example
   * // Delete a few ScheduleLocations
   * const { count } = await prisma.scheduleLocation.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends ScheduleLocationDeleteManyArgs>(args?: Prisma.SelectSubset<T, ScheduleLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ScheduleLocations.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ScheduleLocationUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ScheduleLocations
   * const scheduleLocation = await prisma.scheduleLocation.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends ScheduleLocationUpdateManyArgs>(args: Prisma.SelectSubset<T, ScheduleLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more ScheduleLocations and returns the data updated in the database.
   * @param {ScheduleLocationUpdateManyAndReturnArgs} args - Arguments to update many ScheduleLocations.
   * @example
   * // Update many ScheduleLocations
   * const scheduleLocation = await prisma.scheduleLocation.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more ScheduleLocations and only return the `id`
   * const scheduleLocationWithIdOnly = await prisma.scheduleLocation.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends ScheduleLocationUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, ScheduleLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$ScheduleLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one ScheduleLocation.
   * @param {ScheduleLocationUpsertArgs} args - Arguments to update or create a ScheduleLocation.
   * @example
   * // Update or create a ScheduleLocation
   * const scheduleLocation = await prisma.scheduleLocation.upsert({
   *   create: {
   *     // ... data to create a ScheduleLocation
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ScheduleLocation we want to update
   *   }
   * })
   */
  upsert<T extends ScheduleLocationUpsertArgs>(args: Prisma.SelectSubset<T, ScheduleLocationUpsertArgs<ExtArgs>>): Prisma.Prisma__ScheduleLocationClient<runtime.Types.Result.GetResult<Prisma.$ScheduleLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of ScheduleLocations.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ScheduleLocationCountArgs} args - Arguments to filter ScheduleLocations to count.
   * @example
   * // Count the number of ScheduleLocations
   * const count = await prisma.scheduleLocation.count({
   *   where: {
   *     // ... the filter for the ScheduleLocations we want to count
   *   }
   * })
  **/
  count<T extends ScheduleLocationCountArgs>(
    args?: Prisma.Subset<T, ScheduleLocationCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], ScheduleLocationCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a ScheduleLocation.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ScheduleLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends ScheduleLocationAggregateArgs>(args: Prisma.Subset<T, ScheduleLocationAggregateArgs>): Prisma.PrismaPromise<GetScheduleLocationAggregateType<T>>

  /**
   * Group by ScheduleLocation.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ScheduleLocationGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends ScheduleLocationGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ScheduleLocationGroupByArgs['orderBy'] }
      : { orderBy?: ScheduleLocationGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, ScheduleLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the ScheduleLocation model
 */
readonly fields: ScheduleLocationFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for ScheduleLocation.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ScheduleLocationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  schedule<T extends Prisma.UnitScheduleDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UnitScheduleDefaultArgs<ExtArgs>>): Prisma.Prisma__UnitScheduleClient<runtime.Types.Result.GetResult<Prisma.$UnitSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  location<T extends Prisma.TrainingLocationDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.TrainingLocationDefaultArgs<ExtArgs>>): Prisma.Prisma__TrainingLocationClient<runtime.Types.Result.GetResult<Prisma.$TrainingLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the ScheduleLocation model
 */
export interface ScheduleLocationFieldRefs {
  readonly id: Prisma.FieldRef<"ScheduleLocation", 'Int'>
  readonly unitScheduleId: Prisma.FieldRef<"ScheduleLocation", 'Int'>
  readonly trainingLocationId: Prisma.FieldRef<"ScheduleLocation", 'Int'>
  readonly plannedCount: Prisma.FieldRef<"ScheduleLocation", 'Int'>
  readonly actualCount: Prisma.FieldRef<"ScheduleLocation", 'Int'>
  readonly requiredCount: Prisma.FieldRef<"ScheduleLocation", 'Int'>
}
    

// Custom InputTypes
/**
 * ScheduleLocation findUnique
 */
export type ScheduleLocationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ScheduleLocation
   */
  select?: Prisma.ScheduleLocationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ScheduleLocation
   */
  omit?: Prisma.ScheduleLocationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ScheduleLocationInclude<ExtArgs> | null
  /**
   * Filter, which ScheduleLocation to fetch.
   */
  where: Prisma.ScheduleLocationWhereUniqueInput
}

/**
 * ScheduleLocation findUniqueOrThrow
 */
export type ScheduleLocationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ScheduleLocation
   */
  select?: Prisma.ScheduleLocationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ScheduleLocation
   */
  omit?: Prisma.ScheduleLocationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ScheduleLocationInclude<ExtArgs> | null
  /**
   * Filter, which ScheduleLocation to fetch.
   */
  where: Prisma.ScheduleLocationWhereUniqueInput
}

/**
 * ScheduleLocation findFirst
 */
export type ScheduleLocationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ScheduleLocation
   */
  select?: Prisma.ScheduleLocationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ScheduleLocation
   */
  omit?: Prisma.ScheduleLocationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ScheduleLocationInclude<ExtArgs> | null
  /**
   * Filter, which ScheduleLocation to fetch.
   */
  where?: Prisma.ScheduleLocationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ScheduleLocations to fetch.
   */
  orderBy?: Prisma.ScheduleLocationOrderByWithRelationInput | Prisma.ScheduleLocationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ScheduleLocations.
   */
  cursor?: Prisma.ScheduleLocationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ScheduleLocations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ScheduleLocations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ScheduleLocations.
   */
  distinct?: Prisma.ScheduleLocationScalarFieldEnum | Prisma.ScheduleLocationScalarFieldEnum[]
}

/**
 * ScheduleLocation findFirstOrThrow
 */
export type ScheduleLocationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ScheduleLocation
   */
  select?: Prisma.ScheduleLocationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ScheduleLocation
   */
  omit?: Prisma.ScheduleLocationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ScheduleLocationInclude<ExtArgs> | null
  /**
   * Filter, which ScheduleLocation to fetch.
   */
  where?: Prisma.ScheduleLocationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ScheduleLocations to fetch.
   */
  orderBy?: Prisma.ScheduleLocationOrderByWithRelationInput | Prisma.ScheduleLocationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for ScheduleLocations.
   */
  cursor?: Prisma.ScheduleLocationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ScheduleLocations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ScheduleLocations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of ScheduleLocations.
   */
  distinct?: Prisma.ScheduleLocationScalarFieldEnum | Prisma.ScheduleLocationScalarFieldEnum[]
}

/**
 * ScheduleLocation findMany
 */
export type ScheduleLocationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ScheduleLocation
   */
  select?: Prisma.ScheduleLocationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ScheduleLocation
   */
  omit?: Prisma.ScheduleLocationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ScheduleLocationInclude<ExtArgs> | null
  /**
   * Filter, which ScheduleLocations to fetch.
   */
  where?: Prisma.ScheduleLocationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of ScheduleLocations to fetch.
   */
  orderBy?: Prisma.ScheduleLocationOrderByWithRelationInput | Prisma.ScheduleLocationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing ScheduleLocations.
   */
  cursor?: Prisma.ScheduleLocationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` ScheduleLocations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` ScheduleLocations.
   */
  skip?: number
  distinct?: Prisma.ScheduleLocationScalarFieldEnum | Prisma.ScheduleLocationScalarFieldEnum[]
}

/**
 * ScheduleLocation create
 */
export type ScheduleLocationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ScheduleLocation
   */
  select?: Prisma.ScheduleLocationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ScheduleLocation
   */
  omit?: Prisma.ScheduleLocationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ScheduleLocationInclude<ExtArgs> | null
  /**
   * The data needed to create a ScheduleLocation.
   */
  data: Prisma.XOR<Prisma.ScheduleLocationCreateInput, Prisma.ScheduleLocationUncheckedCreateInput>
}

/**
 * ScheduleLocation createMany
 */
export type ScheduleLocationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many ScheduleLocations.
   */
  data: Prisma.ScheduleLocationCreateManyInput | Prisma.ScheduleLocationCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * ScheduleLocation createManyAndReturn
 */
export type ScheduleLocationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ScheduleLocation
   */
  select?: Prisma.ScheduleLocationSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ScheduleLocation
   */
  omit?: Prisma.ScheduleLocationOmit<ExtArgs> | null
  /**
   * The data used to create many ScheduleLocations.
   */
  data: Prisma.ScheduleLocationCreateManyInput | Prisma.ScheduleLocationCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ScheduleLocationIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * ScheduleLocation update
 */
export type ScheduleLocationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ScheduleLocation
   */
  select?: Prisma.ScheduleLocationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ScheduleLocation
   */
  omit?: Prisma.ScheduleLocationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ScheduleLocationInclude<ExtArgs> | null
  /**
   * The data needed to update a ScheduleLocation.
   */
  data: Prisma.XOR<Prisma.ScheduleLocationUpdateInput, Prisma.ScheduleLocationUncheckedUpdateInput>
  /**
   * Choose, which ScheduleLocation to update.
   */
  where: Prisma.ScheduleLocationWhereUniqueInput
}

/**
 * ScheduleLocation updateMany
 */
export type ScheduleLocationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update ScheduleLocations.
   */
  data: Prisma.XOR<Prisma.ScheduleLocationUpdateManyMutationInput, Prisma.ScheduleLocationUncheckedUpdateManyInput>
  /**
   * Filter which ScheduleLocations to update
   */
  where?: Prisma.ScheduleLocationWhereInput
  /**
   * Limit how many ScheduleLocations to update.
   */
  limit?: number
}

/**
 * ScheduleLocation updateManyAndReturn
 */
export type ScheduleLocationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ScheduleLocation
   */
  select?: Prisma.ScheduleLocationSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the ScheduleLocation
   */
  omit?: Prisma.ScheduleLocationOmit<ExtArgs> | null
  /**
   * The data used to update ScheduleLocations.
   */
  data: Prisma.XOR<Prisma.ScheduleLocationUpdateManyMutationInput, Prisma.ScheduleLocationUncheckedUpdateManyInput>
  /**
   * Filter which ScheduleLocations to update
   */
  where?: Prisma.ScheduleLocationWhereInput
  /**
   * Limit how many ScheduleLocations to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ScheduleLocationIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * ScheduleLocation upsert
 */
export type ScheduleLocationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ScheduleLocation
   */
  select?: Prisma.ScheduleLocationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ScheduleLocation
   */
  omit?: Prisma.ScheduleLocationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ScheduleLocationInclude<ExtArgs> | null
  /**
   * The filter to search for the ScheduleLocation to update in case it exists.
   */
  where: Prisma.ScheduleLocationWhereUniqueInput
  /**
   * In case the ScheduleLocation found by the `where` argument doesn't exist, create a new ScheduleLocation with this data.
   */
  create: Prisma.XOR<Prisma.ScheduleLocationCreateInput, Prisma.ScheduleLocationUncheckedCreateInput>
  /**
   * In case the ScheduleLocation was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.ScheduleLocationUpdateInput, Prisma.ScheduleLocationUncheckedUpdateInput>
}

/**
 * ScheduleLocation delete
 */
export type ScheduleLocationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ScheduleLocation
   */
  select?: Prisma.ScheduleLocationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ScheduleLocation
   */
  omit?: Prisma.ScheduleLocationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ScheduleLocationInclude<ExtArgs> | null
  /**
   * Filter which ScheduleLocation to delete.
   */
  where: Prisma.ScheduleLocationWhereUniqueInput
}

/**
 * ScheduleLocation deleteMany
 */
export type ScheduleLocationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which ScheduleLocations to delete
   */
  where?: Prisma.ScheduleLocationWhereInput
  /**
   * Limit how many ScheduleLocations to delete.
   */
  limit?: number
}

/**
 * ScheduleLocation without action
 */
export type ScheduleLocationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ScheduleLocation
   */
  select?: Prisma.ScheduleLocationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ScheduleLocation
   */
  omit?: Prisma.ScheduleLocationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ScheduleLocationInclude<ExtArgs> | null
}
